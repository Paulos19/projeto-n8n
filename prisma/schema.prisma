// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Avaliacao {
  id String @id @default(cuid())
  nota_cliente          Int?
  pontos_fortes         String[]
  pontos_fracos         String[]
  tempo_resposta        String?
  clareza_comunicacao   String?
  resolucao_problema    String?
  sugestoes_melhoria    String[]
  resumo_atendimento    String?
  remoteJid             String?
  userId    String? // Chave estrangeira para User
  user      User?   @relation(fields: [userId], references: [id])
  sellerEvolutionApiKey String? // RENOMEADO: Chave API da instância Evolution do VENDEDOR que gerou esta avaliação
  sellerId              String? // NOVO CAMPO: Chave estrangeira para Seller
  seller                Seller? @relation(fields: [sellerId], references: [id]) // NOVA RELAÇÃO
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId]) // Adicionando índice se ainda não existir explicitamente para userId
  @@index([sellerId]) // NOVO ÍNDICE
  @@map("avaliacoes")
}

// Modelos para NextAuth.js / Auth.js
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  identifier    String?   @unique
  passwordHash  String?
  webhookApiKey String?   @unique // Chave principal da loja/usuário (dono da loja)
  instanceName  String?   // Nome geral da instância da loja (opcional)

  accounts         Account[]
  sessions         Session[]
  avaliacoes       Avaliacao[]
  chatInteractions ChatInteraction[] // Interações gerais da loja (se aplicável)
  
  // Relação: Dono da loja para com seus vendedores
  sellers          Seller[]          @relation("StoreOwnerToSellers")

  @@map("users")
}

// Novo modelo para Vendedores
model Seller {
  id                    String  @id @default(cuid())
  name                  String? // Nome de exibição para o vendedor (ex: "Paulo Henrique Vendas")
  evolutionInstanceName String  // Nome da instância na Evolution API (do webhook: body.instance)
  evolutionApiKey       String  // Chave da Evolution API específica deste vendedor (do webhook: body.apikey)
  sellerWhatsAppNumber  String  // Número do WhatsApp da instância Evolution do vendedor (informado pelo dono da loja)
  isActive              Boolean @default(true) // Para ativar/desativar vendedor

  storeOwnerId String // Chave estrangeira para o User (dono da loja)
  storeOwner   User   @relation("StoreOwnerToSellers", fields: [storeOwnerId], references: [id])

  avaliacoes       Avaliacao[]       // Relação inversa para Avaliacoes
  chatInteractions ChatInteraction[] // Interações de chat atribuídas a este vendedor

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([storeOwnerId, evolutionInstanceName]) // Nome da instância deve ser único por loja
  @@unique([storeOwnerId, evolutionApiKey])       // API Key da Evolution deve ser única por loja
  @@unique([storeOwnerId, sellerWhatsAppNumber])  // Número do WhatsApp do vendedor deve ser único por loja
  @@map("sellers")
}

model ChatInteraction {
  id               String   @id @default(cuid())
  remoteJid        String   // JID do cliente
  customerName     String   // Nome do cliente (pushName)
  chatHistory      Json
  analysisSummary  String?
  analysisKeywords String[]
  eventTimestamp   DateTime
  
  // Pode ser populado com Seller.name ou Seller.evolutionInstanceName para display rápido
  // Este campo pode se tornar redundante se sempre usarmos os dados do Seller relacionado.
  sellerInstanceName String?  

  // ID do dono da loja (quem "possui" a webhookApiKey principal usada na URL da API)
  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  // ID do vendedor específico que lidou com a interação
  sellerId String?
  seller   Seller? @relation(fields: [sellerId], references: [id])

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([remoteJid])
  @@index([eventTimestamp])
  @@index([userId])
  @@index([sellerId]) // Novo índice
  @@map("chat_interactions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}
